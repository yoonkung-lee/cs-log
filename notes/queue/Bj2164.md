# ArrayDeque vs LinkedList 성능 비교 📊

## 테스트 개요

* **요소 수:** 500,000
* **측정 지표:**

    * 메모리 사용량 (MB) 🧠
    * 실행 시간 (ms) ⏱️

### 결과 요약

| 자료구조       | 메모리 사용량 (MB) | 실행 시간 (ms) |
| ---------- | ------------ | ---------- |
| ArrayDeque | 16.94        | 33         |
| LinkedList | 23.73        | 83         |

---

## 성능 차이 분석 🔍

### 1. **메모리 사용량 차이** 🧮

* **ArrayDeque**는 내부적으로 크기 조절 가능한 배열로 구현됨.

    * 연속된 메모리 블록에 데이터를 저장하여 공간 효율이 높음.
    * 요소 당 오버헤드가 적음 (배열의 슬롯만 사용)
* **LinkedList**는 각 요소를 노드 객체로 저장하며:

    * 값 + 이전 노드 + 다음 노드 포인터를 포함
    * **노드 객체와 포인터로 인한 오버헤드 큼**

> ✅ 따라서, `LinkedList`는 노드 구조로 인해 `ArrayDeque`보다 메모리를 더 많이 사용함.

### 2. **실행 시간 차이** ⚡

* **ArrayDeque**:

    * 양 끝 삽입/삭제는 평균적으로 O(1)
    * 배열 기반이라 **캐시 친화적(cache-friendly)**
    * 순회 및 접근이 빠름
* **LinkedList**:

    * 양 끝 삽입/삭제는 O(1)이지만,
    * 포인터 탐색(pointer chasing)으로 인해 순회 및 접근이 느림
    * **캐시 효율이 낮음**

> ⏳ 결과적으로, `ArrayDeque`가 시간 면에서도 `LinkedList`보다 훨씬 효율적임.

---

## 결론 ✅

* 일반적인 큐/덱 구현에서는 **ArrayDeque** 사용을 권장함.
* 예외적으로 다음의 경우엔 **LinkedList**를 고려할 수 있음:

    * 중간 삽입/삭제가 빈번한 경우
    * 이중 연결 리스트 알고리즘을 명시적으로 구현해야 하는 경우

### 💡 추천

> Java에서 스택, 큐, 덱 등을 성능 중심으로 구현할 때는 `ArrayDeque`를 기본 선택지로 삼는 것이 좋습니다.